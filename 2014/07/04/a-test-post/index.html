

<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <script type="text/javascript" src="http://tajs.qq.com/stats?sId=44218032" charset="UTF-8"></script>
  <script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?7192fa361f5cabb11d8a22de41c1ba8f";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>
  
  <title>UITextField汇总一:呈现篇 | 白驹过隙 点滴于心</title>
  <meta name="author" content="李天昊">
  
  <meta name="description" content="李天昊的技术博">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="UITextField汇总一:呈现篇"/>
  <meta property="og:site_name" content="白驹过隙 点滴于心"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/imgs/favicon.ico" rel="icon" type="image/x-ico">
  <link rel="alternate" href="/atom.xml" title="白驹过隙 点滴于心" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//libs.baidu.com/jquery/1.8.0/jquery.min.js"></script>
</head>


<body>
  <header><div>
		
			<div id="imglogo">
				<a href="/"><img src="/imgs/logo.png" alt="白驹过隙 点滴于心" title="白驹过隙 点滴于心"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name">白驹过隙 点滴于心</h1>
				<h2 class="blog-motto">Talk is cheap. Show me the code!</h2>
			</div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li> <a href="/atom.xml">RSS</a> </li>
				</ul>
			</nav>			
</div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header class="article-info clearfix">
  <h1 itemprop="name">
	UITextField汇总一:呈现篇
  </h1>
  <p class="article-author">By
    
      <a href="www.yoursite.com" title="李天昊">李天昊</a>
    </p>
  <p class="article-time">
    <time datetime="2014-07-04T01:19:40.000Z" itemprop="datePublished">2014-07-04</time>
    更新日期:<time datetime="2016-07-04T09:29:04.000Z" itemprop="dateModified">2016-07-04</time>
    
  </p>
</header>
    <div class="entry">
		
        <h1 id="UITextField汇总一-呈现篇"><a href="#UITextField汇总一-呈现篇" class="headerlink" title="UITextField汇总一:呈现篇"></a>UITextField汇总一:呈现篇</h1><p>@(UITextField呈现)[自身显示属性|keyBoard相关属性|UIPasteboard相关属性|自定义UITextField方法]<br><strong>UITextField</strong>是iOS开发中用到的最常用系统控件之一,我们可以用它来接收用户输入的信息,我们使用它来完成用户交互时,多半要涉及到系统键盘的调用和收回,因此可以说UITextField是比较复杂的控件,本系列文章将从以下三个方向对UITextField控件做一个较完整的总结.本文为第一篇:呈现.</p>
<ul>
<li><strong>呈现</strong><ul>
<li>自身显示属性</li>
<li>keyBoard相关属性</li>
<li>UIPasteboard相关属性</li>
<li>自定义UITextField方法</li>
</ul>
</li>
<li><strong>交互</strong><ul>
<li>响应touch事件</li>
<li>接受用户信息</li>
</ul>
</li>
<li><strong>代码回调</strong><ul>
<li>Delegate</li>
<li>Notification</li>
<li>Target-Action </li>
</ul>
</li>
</ul>
<hr>
<p>###呈现</p>
<h5 id="·自身显示属性"><a href="#·自身显示属性" class="headerlink" title="·自身显示属性"></a>·自身显示属性</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//初始化方法 , 可以直接指定frame  也可以先init  再在适当时机给frame属性赋值</span></div><div class="line"><span class="built_in">UITextField</span> *myTextF = [[<span class="built_in">UITextField</span> alloc] initWithFrame:frame];</div><div class="line"></div><div class="line"><span class="comment">//文本框中的内容 , 随着用户输入改变而变 , 可以用代码设置默认值 ,实际上得到的用户输入数据就是由这个而来</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)   <span class="built_in">NSString</span> *text; </div><div class="line"></div><div class="line"><span class="comment">//属性文本 可以设置指定range内的文本样式(颜色 下划线 中划线等等)</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)   <span class="built_in">NSAttributedString</span>     *attributedText <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0); </div><div class="line"><span class="comment">//文本颜色 默认是nil  系统监测到该属性是nil 就会给一个不透明的黑色</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">UIColor</span>                *textColor;  </div><div class="line"><span class="comment">//字体 默认 system font 12 pt</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">UIFont</span>                 *font;          </div><div class="line"><span class="comment">//文本对齐方式 默认左对齐 iOS6.0 之后弃用UITextAlignment枚举 统一用NSTextAlignment枚举 常用的有center left right三个选项</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">NSTextAlignment</span> textAlignment;</div><div class="line"></div><div class="line"><span class="comment">// 边框样式 默认为none   </span></div><div class="line"><span class="comment">//    UITextBorderStyleNone,       无样式</span></div><div class="line"><span class="comment">//    UITextBorderStyleLine,      线型(此处截图)</span></div><div class="line">      ![Alt text](./images/border_line.png)</div><div class="line"><span class="comment">//    UITextBorderStyleBezel,     刃角(此处截图)</span></div><div class="line">      ![Alt text](./images/border_bezel.png)</div><div class="line"><span class="comment">//    UITextBorderStyleRoundedRect  圆角(此处截图)</span></div><div class="line">      ![Alt text](./images/border_roundrect.png)</div><div class="line"><span class="comment">//  注意: UITextBorderStyleRoundedRect 就是切圆角  会屏蔽掉background images属性</span></div><div class="line"><span class="comment">//   我一般是 直接设置uitextfield的layer.bordercolor 和 borderwidth  这样不会屏蔽background设置的image属性 (效果截图)</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)<span class="built_in">UITextBorderStyle</span> borderStyle; </div><div class="line">      </div><div class="line"><span class="comment">// 占位文本 默认为亮灰色水印样式</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)   <span class="built_in">NSString</span>               *placeholder; </div><div class="line"></div><div class="line"><span class="comment">// 整个属性字符串的属性字典 iOS7.0以后的接口 这条和下面的attributedPlaceholder都很少用到</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)   <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt;           *defaultTextAttributes <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0);    </div><div class="line"><span class="comment">//  占位的属性文本</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)   <span class="built_in">NSAttributedString</span>     *attributedPlaceholder <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0); </div><div class="line"></div><div class="line"><span class="comment">//  是否在开始编辑时 清除文本中上次遗留的text  默认是NO</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)<span class="built_in">BOOL</span> clearsOnBeginEditing; </div><div class="line"></div><div class="line"><span class="comment">//自动调整字体适应控件宽度 默认是No </span></div><div class="line"><span class="comment">// 如果是NO 文本在较长时会滚动</span></div><div class="line"><span class="comment">// 如果是YES 文本在超过控件宽度时 会缩小到下面属性设置的minimumFontSize大小 缩小的规则是基线位置不变 整体变低</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)<span class="built_in">BOOL</span> adjustsFontSizeToFitWidth;</div><div class="line"><span class="comment">//设置最小字体 为上边属性准备的属性</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)<span class="built_in">CGFloat</span> minimumFontSize;      </div><div class="line"><span class="comment">// 代理 这个你懂得.... 后面会有着重说代理回调的地方</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">weak</span>)<span class="keyword">id</span>&lt;<span class="built_in">UITextFieldDelegate</span>&gt; delegate; </div><div class="line"><span class="comment">//背景图片 默认是nil  设置的图片会被画在borderview上 图片像素尺寸不对会被拉伸或挤压 要设置中间拉伸填充区域 使拉伸不变形</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">UIImage</span> *background;           </div><div class="line"><span class="comment">// 禁用状态下的背景图片 注意点同上一个属性</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">UIImage</span> *disabledBackground;   </div><div class="line"><span class="comment">// 指示当前控件是否正在编辑</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">getter</span>=isEditing) <span class="built_in">BOOL</span> editing;</div><div class="line"></div><div class="line"><span class="comment">// 文本框里面几个子视图的显示模式 : </span></div><div class="line"><span class="comment">//   UITextFieldViewModeNever,         从不</span></div><div class="line"><span class="comment">//   UITextFieldViewModeWhileEditing,  编辑时显示</span></div><div class="line"><span class="comment">//   UITextFieldViewModeUnlessEditing, 编辑以外时间显示</span></div><div class="line"><span class="comment">//   UITextFieldViewModeAlways         一直显示</span></div><div class="line"></div><div class="line"><span class="comment">//   右侧清除按钮的显示模式</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)<span class="built_in">UITextFieldViewMode</span> clearButtonMode; </div><div class="line"></div><div class="line"><span class="comment">//左边视图 一般要一个占位的8个点宽度的视图 切圆角后 左边光标被挡出  (一般如果只要占位效果 只设置这个视图的宽度就够了)</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">UIView</span>              *leftView;        <span class="comment">// e.g. magnifying glass</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)        <span class="built_in">UITextFieldViewMode</span>  leftViewMode;    <span class="comment">// sets when the left view shows up. default is UITextFieldViewModeNever</span></div><div class="line"><span class="comment">//右边视图</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">UIView</span>  *rightView;</div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">UITextFieldViewMode</span>  rightViewMode;</div></pre></td></tr></table></figure>
<h5 id="·keyBoard相关属性"><a href="#·keyBoard相关属性" class="headerlink" title="·keyBoard相关属性"></a>·keyBoard相关属性</h5><h5 id="系统键盘高度为216pt-辅助视图40pt-系统默认的辅助视图是给我们选的联想词语的-一般键盘弹出后为了躲避键盘-被键盘挡住的区域要做适当的移动动画-这个后面的回调篇说具体方法"><a href="#系统键盘高度为216pt-辅助视图40pt-系统默认的辅助视图是给我们选的联想词语的-一般键盘弹出后为了躲避键盘-被键盘挡住的区域要做适当的移动动画-这个后面的回调篇说具体方法" class="headerlink" title="系统键盘高度为216pt , 辅助视图40pt (系统默认的辅助视图是给我们选的联想词语的) 一般键盘弹出后为了躲避键盘 , 被键盘挡住的区域要做适当的移动动画, 这个后面的回调篇说具体方法"></a>系统键盘高度为216pt , 辅助视图40pt (系统默认的辅助视图是给我们选的联想词语的) 一般键盘弹出后为了躲避键盘 , 被键盘挡住的区域要做适当的移动动画, 这个后面的回调篇说具体方法</h5><h6 id="以下两个属性可以自定义键盘区域的视图以及键盘上方的辅助视图-就是上一个-下一个-完成-等等"><a href="#以下两个属性可以自定义键盘区域的视图以及键盘上方的辅助视图-就是上一个-下一个-完成-等等" class="headerlink" title="以下两个属性可以自定义键盘区域的视图以及键盘上方的辅助视图(就是上一个 , 下一个 , 完成 等等) ,"></a>以下两个属性可以自定义键盘区域的视图以及键盘上方的辅助视图(就是上一个 , 下一个 , 完成 等等) ,</h6><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  自定义的输入视图 </span></div><div class="line"><span class="comment">//  一般是pickerview 或者datepicker , 又或者是用UICollectionView写的自定义emoji键盘</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">readwrite</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *inputView;    </div><div class="line"><span class="comment">//  自定义的辅助视图 就是键盘上方的那一条          </span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">readwrite</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *inputAccessoryView;</div><div class="line"><span class="comment">//  自己试了几次 没啥效果 字面意思是插入的时候清除之前的文本 但是我试的时候并没有起作用 , 看注释的意思貌似是要在与用户交互的时候动态改变这个值 , 这个是也会根据用户的交互选中情况不同而自己改变 </span></div><div class="line"><span class="comment">//总之实际开发中没有涉及到 试了几次无果 就没再研究</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> clearsOnInsertion <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</div></pre></td></tr></table></figure>
<h6 id="UITextInputTraits-UIKit-中有这样一个类的接口-专门提供给开发者定制keyBoard样式-UITextfield中有几个属性可以定制键盘样式-它们是UITextInputTraits协议中暴露出来的属性接口-实现它就可以达到与系统通信-定制keyboard样式的目的-其实现原理应该是当keyboard要出现时-系统以一定时序调用UITextInputTraits代理中的j接口方法取出对应的样式信息-然后展现-这个代理不仅可以服务于UITextfield-还可以用于UITextView-或者我们自定义的一些需要键盘样式的空间中-只要我们遵守并实现了这个代理"><a href="#UITextInputTraits-UIKit-中有这样一个类的接口-专门提供给开发者定制keyBoard样式-UITextfield中有几个属性可以定制键盘样式-它们是UITextInputTraits协议中暴露出来的属性接口-实现它就可以达到与系统通信-定制keyboard样式的目的-其实现原理应该是当keyboard要出现时-系统以一定时序调用UITextInputTraits代理中的j接口方法取出对应的样式信息-然后展现-这个代理不仅可以服务于UITextfield-还可以用于UITextView-或者我们自定义的一些需要键盘样式的空间中-只要我们遵守并实现了这个代理" class="headerlink" title="UITextInputTraits :UIKit 中有这样一个类的接口 专门提供给开发者定制keyBoard样式 , UITextfield中有几个属性可以定制键盘样式 , 它们是UITextInputTraits协议中暴露出来的属性接口,实现它就可以达到与系统通信,定制keyboard样式的目的, 其实现原理应该是当keyboard要出现时, 系统以一定时序调用UITextInputTraits代理中的j接口方法取出对应的样式信息, 然后展现 , 这个代理不仅可以服务于UITextfield , 还可以用于UITextView 或者我们自定义的一些需要键盘样式的空间中, 只要我们遵守并实现了这个代理"></a>UITextInputTraits :UIKit 中有这样一个类的接口 专门提供给开发者定制keyBoard样式 , UITextfield中有几个属性可以定制键盘样式 , 它们是UITextInputTraits协议中暴露出来的属性接口,实现它就可以达到与系统通信,定制keyboard样式的目的, 其实现原理应该是当keyboard要出现时, 系统以一定时序调用UITextInputTraits代理中的j接口方法取出对应的样式信息, 然后展现 , 这个代理不仅可以服务于UITextfield , 还可以用于UITextView 或者我们自定义的一些需要键盘样式的空间中, 只要我们遵守并实现了这个代理</h6><h6 id="以下是这个协议的头文件信息"><a href="#以下是这个协议的头文件信息" class="headerlink" title="以下是这个协议的头文件信息"></a>以下是这个协议的头文件信息</h6><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// UITextInputTraits</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  提供定制文本工具的控件特性(或者其他可能需要响应键盘输入的自定义对象)</span></div><div class="line"><span class="comment">// Controls features of text widgets (or other custom objects that might wish </span></div><div class="line"><span class="comment">// to respond to keyboard input).</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UITextInputTraits</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@optional</span></div><div class="line"></div><div class="line"><span class="comment">// 是否为密文输入</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">getter</span>=isSecureTextEntry) <span class="built_in">BOOL</span> secureTextEntry;  </div><div class="line"><span class="comment">// 首字母大写样式</span></div><div class="line"><span class="comment">//    UITextAutocapitalizationTypeNone,     默认无样式</span></div><div class="line"><span class="comment">//    UITextAutocapitalizationTypeWords,    以单词为单位</span></div><div class="line"><span class="comment">//    UITextAutocapitalizationTypeSentences,以句子为单位(这是默认值)</span></div><div class="line"><span class="comment">//    UITextAutocapitalizationTypeAllCharacters,每个字符都大写</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">UITextAutocapitalizationType</span> autocapitalizationType;</div><div class="line"><span class="comment">//   自动修正</span></div><div class="line"><span class="comment">//   UITextAutocorrectionTypeDefault,  由系统自己决定是否开启(默认值)</span></div><div class="line"><span class="comment">//   UITextAutocorrectionTypeNo,       开启</span></div><div class="line"><span class="comment">//   UITextAutocorrectionTypeYes,      关闭</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">UITextAutocorrectionType</span> autocorrectionType; </div><div class="line"></div><div class="line"><span class="comment">// 拼写检查  同上 有三个选项          </span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">UITextSpellCheckingType</span> spellCheckingType <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//  键盘样式</span></div><div class="line"><span class="comment">//   UIKeyboardTypeDefault,       默认样式 , 就是我们见到的最多的那种</span></div><div class="line">      ![Alt text](./images/<span class="number">1.</span>png)</div><div class="line"><span class="comment">//   UIKeyboardTypeASCIICapable,  ASCII码样式  </span></div><div class="line">      ![Alt text](./images/<span class="number">2.</span>png)</div><div class="line"><span class="comment">//   UIKeyboardTypeNumbersAndPunctuation,  数字和标点符号</span></div><div class="line">      ![Alt text](./images/<span class="number">3.</span>png)</div><div class="line"><span class="comment">//   UIKeyboardTypeURL,             网址URL符号键盘</span></div><div class="line">      ![Alt text](./images/<span class="number">4.</span>png)</div><div class="line"><span class="comment">//   UIKeyboardTypeNumberPad,       纯数字键盘</span></div><div class="line">      ![Alt text](./images/<span class="number">5.</span>png)</div><div class="line"><span class="comment">//   UIKeyboardTypePhonePad,        电话号码键盘  1-9, *, 0, #,</span></div><div class="line">      ![Alt text](./images/<span class="number">6.</span>png)</div><div class="line"><span class="comment">//   UIKeyboardTypeNamePhonePad,    联系人键盘</span></div><div class="line"><span class="comment">//   UIKeyboardTypeEmailAddress,         电子邮件</span></div><div class="line">      ![Alt text](./images/<span class="number">8.</span>png)</div><div class="line"><span class="comment">//   UIKeyboardTypeDecimalPad 带小数点的数字键盘   </span></div><div class="line"><span class="comment">//   UIKeyboardTypeTwitter 推特专用键盘</span></div><div class="line"><span class="comment">//   UIKeyboardTypeWebSearch iOS7.0以后  网页搜索键盘</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">UIKeyboardType</span> keyboardType;                         </div><div class="line"></div><div class="line"><span class="comment">// 键盘外观显示  字面意思已经很明显了 就不多说了 本来有4个属性 但是第四个已经禁用 , 它和第二个是一个意思</span></div><div class="line"><span class="comment">//  UIKeyboardAppearanceDefault,     </span></div><div class="line"><span class="comment">//  UIKeyboardAppearanceDark NS_ENUM_AVAILABLE_IOS(7_0),</span></div><div class="line"><span class="comment">//  UIKeyboardAppearanceLight NS_ENUM_AVAILABLE_IOS(7_0),</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">UIKeyboardAppearance</span> keyboardAppearance;             </div><div class="line"></div><div class="line"><span class="comment">// 返回键样式 就是键盘右下角的那个按钮 有一个delegate方法 shouldreturn和这个按键对应, 我一般用这个按键做结束输入提交功能信息</span></div><div class="line"><span class="comment">// 有以下几种样式  这个也不用多说 一般后缀是什么 按钮就显示什么 default显示return</span></div><div class="line"><span class="comment">/*  UIReturnKeyDefault,</span></div><div class="line">    UIReturnKeyGo,</div><div class="line">    UIReturnKeyGoogle,</div><div class="line">    UIReturnKeyJoin,</div><div class="line">    UIReturnKeyNext,</div><div class="line">    UIReturnKeyRoute,</div><div class="line">    UIReturnKeySearch,</div><div class="line">    UIReturnKeySend,</div><div class="line">    UIReturnKeyYahoo,</div><div class="line">    UIReturnKeyDone,</div><div class="line">    UIReturnKeyEmergencyCall,</div><div class="line">    UIReturnKeyContinue NS_ENUM_AVAILABLE_IOS(9_0),</div><div class="line"> */</div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">UIReturnKeyType</span> returnKeyType;  </div><div class="line"><span class="comment">// 这个属性设置为YES时 如果文本框内没有字符, return按钮就会变为灰色禁用                     </span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> enablesReturnKeyAutomatically;                  <span class="comment">// default is NO (when YES, will automatically disable return key when text widget has zero-length contents, and will automatically enable when text widget has non-zero-length contents)</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h5 id="·-UIMenuController相关设置"><a href="#·-UIMenuController相关设置" class="headerlink" title="· UIMenuController相关设置"></a>· UIMenuController相关设置</h5><p>######在用户与文本框交互时 , 可能会使用系统的复制,粘贴,剪切等功能, 这时就会有一个UIMenuController出来与用户交互, 就是我们长按或者双击文本框跳出来的黑色选框, 上面有copy , cut , paste , select all 等等选项, 这个视图是可以定制的, UIKit中有对应的api ,而文本框具体能响应那种操作,也可以有开发者决定, 在输入密码时,我们通常不希望用户使用其他地方复制来的信息或者复制密码框里的文本, 这都可以通过重写UIRespond的方法</p>
<p>######- (BOOL)canPerformAction:(SEL)action withSender:(id)sender来实现</p>
<p>######具体方法:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)canPerformAction:(SEL)action withSender:(<span class="keyword">id</span>)sender</div><div class="line">&#123;</div><div class="line"><span class="comment">// 可以在这里log到系统在我们双击或长按文本框时都掉了什么方法 , 调了几次</span></div><div class="line"><span class="comment">// 文本框中没有字符时,是不会跳出select和cut , copy选项的 只有一个paste</span></div><div class="line"><span class="comment">// 我通过实验发现文本框中没有值和有值的时候action的数量和种类是固定的,猜测就是在这个方法中 父类针对文本中是否有字符返回是否可以复制或粘贴</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span> ,<span class="built_in">NSStringFromSelector</span>( action));</div><div class="line">      <span class="keyword">if</span> (action == <span class="keyword">@selector</span>(paste:)</div><div class="line">        || action == <span class="keyword">@selector</span>(<span class="keyword">copy</span>)</div><div class="line">        || action == <span class="keyword">@selector</span>(cut:)) </div><div class="line">        &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        &#125;</div><div class="line">    <span class="comment">//我们只阻止复制和粘贴 , 剪切 这三个选项 其他的还是交个系统决定</span></div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> canPerformAction:action withSender:sender];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>######这样就过滤掉了复制剪切和粘贴<br>      <img src="./images/menu_tail.gif" alt="Alt text"></p>
<h6 id="UIMenuController是单例-只能用sharedMenuController来获取实例-用alloc-init会崩溃报错-以下是为一个文本框添加一个UIMenuController选项按钮的方法"><a href="#UIMenuController是单例-只能用sharedMenuController来获取实例-用alloc-init会崩溃报错-以下是为一个文本框添加一个UIMenuController选项按钮的方法" class="headerlink" title="UIMenuController是单例 , 只能用sharedMenuController来获取实例, 用alloc init会崩溃报错 ,  以下是为一个文本框添加一个UIMenuController选项按钮的方法"></a>UIMenuController是单例 , 只能用sharedMenuController来获取实例, 用alloc init会崩溃报错 ,  以下是为一个文本框添加一个UIMenuController选项按钮的方法</h6><h6 id="不止文本框可以呼出UIMenuController-任何一个UIRespond都能呼出UIMenuController-可以通过UIMenuController头文件提供的接口自定义UIMenuController的显示时机-通过menuItems数组来控制UIMenuController的显示选项"><a href="#不止文本框可以呼出UIMenuController-任何一个UIRespond都能呼出UIMenuController-可以通过UIMenuController头文件提供的接口自定义UIMenuController的显示时机-通过menuItems数组来控制UIMenuController的显示选项" class="headerlink" title="不止文本框可以呼出UIMenuController , 任何一个UIRespond都能呼出UIMenuController , 可以通过UIMenuController头文件提供的接口自定义UIMenuController的显示时机,通过menuItems数组来控制UIMenuController的显示选项"></a>不止文本框可以呼出UIMenuController , 任何一个UIRespond都能呼出UIMenuController , 可以通过UIMenuController头文件提供的接口自定义UIMenuController的显示时机,通过menuItems数组来控制UIMenuController的显示选项</h6><h6 id="仔细看的大神们可能会注意到-我并没有在这个自定义类中的任何时机移除自己添加的item按钮-因为UIMenuController是个单例-如果我现在有ABC三个自定义THTextField文本框-若我再dealloc中写了移除item的代码-那么最先销毁的THTextField就会带走这个item-而后两个就掉不出这个按钮了-因为无论添加几次-这个item只在内存中有一份-移除一次它就没了-所以索性不移除了-在系统通过anPerformAction-SEL-action-withSender-id-sender这个方法询问是否显示我的自定义item时-return-YES就好了"><a href="#仔细看的大神们可能会注意到-我并没有在这个自定义类中的任何时机移除自己添加的item按钮-因为UIMenuController是个单例-如果我现在有ABC三个自定义THTextField文本框-若我再dealloc中写了移除item的代码-那么最先销毁的THTextField就会带走这个item-而后两个就掉不出这个按钮了-因为无论添加几次-这个item只在内存中有一份-移除一次它就没了-所以索性不移除了-在系统通过anPerformAction-SEL-action-withSender-id-sender这个方法询问是否显示我的自定义item时-return-YES就好了" class="headerlink" title="仔细看的大神们可能会注意到 我并没有在这个自定义类中的任何时机移除自己添加的item按钮, 因为UIMenuController是个单例, 如果我现在有ABC三个自定义THTextField文本框, 若我再dealloc中写了移除item的代码 , 那么最先销毁的THTextField就会带走这个item , 而后两个就掉不出这个按钮了, 因为无论添加几次, 这个item只在内存中有一份, 移除一次它就没了,所以索性不移除了, 在系统通过anPerformAction:(SEL)action withSender:(id)sender这个方法询问是否显示我的自定义item时 , return YES就好了."></a>仔细看的大神们可能会注意到 我并没有在这个自定义类中的任何时机移除自己添加的item按钮, 因为UIMenuController是个单例, 如果我现在有ABC三个自定义THTextField文本框, 若我再dealloc中写了移除item的代码 , 那么最先销毁的THTextField就会带走这个item , 而后两个就掉不出这个按钮了, 因为无论添加几次, 这个item只在内存中有一份, 移除一次它就没了,所以索性不移除了, 在系统通过anPerformAction:(SEL)action withSender:(id)sender这个方法询问是否显示我的自定义item时 , return YES就好了.</h6><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">THTextField</span></span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ( <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame]) &#123;</div><div class="line">        <span class="built_in">UIMenuController</span> *menu = [<span class="built_in">UIMenuController</span> sharedMenuController];</div><div class="line">        <span class="built_in">NSMutableArray</span> *arrM = menu.menuItems.mutableCopy ;</div><div class="line">        <span class="keyword">if</span> (arrM == <span class="literal">nil</span>) &#123;</div><div class="line">            arrM = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">        &#125;</div><div class="line">        [arrM addObject: [[<span class="built_in">UIMenuItem</span> alloc] initWithTitle:<span class="string">@"天昊"</span> action:<span class="keyword">@selector</span>(tianhao)]];</div><div class="line">        menu.menuItems = arrM.copy ;</div><div class="line">    &#125;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">self</span> ;</div><div class="line">&#125;</div><div class="line">- (<span class="built_in">BOOL</span>)canPerformAction:(SEL)action withSender:(<span class="keyword">id</span>)sender</div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (action == <span class="keyword">@selector</span>(tianhao)) &#123;</div><div class="line">        <span class="keyword">return</span>  <span class="literal">YES</span> ;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> canPerformAction:action withSender:sender];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)tianhao</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"天昊"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>######具体效果如图:<br>      <img src="./images/menu_zhanshji.gif" alt="Alt text"></p>
<h5 id="·-自定义UITextField方法"><a href="#·-自定义UITextField方法" class="headerlink" title="· 自定义UITextField方法"></a>· 自定义UITextField方法</h5><p>######在UITextfield的头文件中有这样一段接口:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// drawing and positioning overrides</span></div><div class="line">- (<span class="built_in">CGRect</span>)borderRectForBounds:(<span class="built_in">CGRect</span>)bounds;</div><div class="line">- (<span class="built_in">CGRect</span>)textRectForBounds:(<span class="built_in">CGRect</span>)bounds;</div><div class="line">- (<span class="built_in">CGRect</span>)placeholderRectForBounds:(<span class="built_in">CGRect</span>)bounds;</div><div class="line">- (<span class="built_in">CGRect</span>)editingRectForBounds:(<span class="built_in">CGRect</span>)bounds;</div><div class="line">- (<span class="built_in">CGRect</span>)clearButtonRectForBounds:(<span class="built_in">CGRect</span>)bounds;</div><div class="line">- (<span class="built_in">CGRect</span>)leftViewRectForBounds:(<span class="built_in">CGRect</span>)bounds;</div><div class="line">- (<span class="built_in">CGRect</span>)rightViewRectForBounds:(<span class="built_in">CGRect</span>)bounds;</div><div class="line"></div><div class="line"><span class="comment">// 这两个方法是系统在已经得到了文本区域或占位文本区域后 将要把对应的文字画到矩形区域是调用, 知道了这个调用时机 , 就可以重写这个方法来实现一些特定的效果了(比如让每个字都倾斜一定角度, 修改每个字的颜色让它们都不同等等)</span></div><div class="line">- (<span class="keyword">void</span>)drawTextInRect:(<span class="built_in">CGRect</span>)rect;</div><div class="line">- (<span class="keyword">void</span>)drawPlaceholderInRect:(<span class="built_in">CGRect</span>)rect;</div></pre></td></tr></table></figure></p>
<p>######注释中写着 drawing and positioning overrides </p>
<p>######没错 , 就是提供给自定义子类重写的方法 , 在这些方法里返回对应的CGRect ,就会让系统在渲染我们的自定义文本框是将边框,文本,占位文本,编辑区域,clearButton,左,右视图画在我们指定的rect中, 我一般的做法是先在方法体中用super的该方法得到原本的rect 然后做适当修改, 我们哪第一个边框rect做例子(其他几个类比着来,都是一样的):<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CGRect</span>)borderRectForBounds:(<span class="built_in">CGRect</span>)bounds</div><div class="line">&#123;</div><div class="line"><span class="comment">// 先调用父类方法 得到原始frame  再自行修改返回</span></div><div class="line">    <span class="built_in">CGRect</span> originFrame = [<span class="keyword">super</span> borderRectForBounds:bounds];</div><div class="line">    originFrame.origin.x += <span class="number">10</span> ;</div><div class="line">    <span class="keyword">return</span> originFrame;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下一篇来讲UITextfield的交互</p>

    </div>
    <footer>
        
        
  
  <div class="tags">
    <a href="/tags/UITextField/">UITextField</a>
  </div>

		<div class="bdsharebuttonbox">
	<a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
	<a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博"></a>
	<a href="#" class="bds_renren" data-cmd="renren" title="分享到人人网"></a>
	<a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
	<a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
	<a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
	<a href="#" class="bds_more" data-cmd="more"></a>
	<a href="#" class="bds_count" data-cmd="count"></a>
</div>
<script>
window._bd_share_config=
{
	"common":{
		"bdSnsKey":{},
		"bdText":"",
		"bdMini":"2",
		"bdMiniList":false,
		"bdPic":"",
		"bdStyle":"0",
		"bdSize":"24"
	},
	"share":{},
	"image":{
		"viewList":["qzone","tsina","tqq","renren","weixin","fbook","twi"],
		"viewText":"分享到：",
		"viewSize":"24"
	},
	"selectShare":{
		"bdContainerClass":null,
		"bdSelectMiniList":["qzone","tsina","tqq","renren","weixin","fbook","twi"]
	}
};
with(document)0[
	(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)
];
</script>    
        <div class="clearfix"></div>
    </footer>
  </div>
</article>

 <nav id="pagination" >
    
    <a href="/2016/07/04/untitled/" class="alignleft prev" title=""></a>
    
    
    <div class="clearfix"></div>
</nav>



	
	<section id="comment">
		<!-- 多说评论框 start -->
		<div class="ds-thread" data-thread-key="2014/07/04/a-test-post/" data-title="UITextField汇总一:呈现篇" data-url="www.yoursite.com/2014/07/04/a-test-post/"></div>
		<!-- 多说评论框 end -->
		<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
		<script type="text/javascript">
		var duoshuoQuery = {short_name:""};
		(function() {
			var ds = document.createElement('script');
			ds.type = 'text/javascript';ds.async = true;
			ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
			ds.charset = 'UTF-8';
			(document.getElementsByTagName('head')[0] 
			 || document.getElementsByTagName('body')[0]).appendChild(ds);
		})();
		</script>
		<!-- 多说公共JS代码 end -->
	</section>
	
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:www.yoursite.com">
  </form>
</div>

  

  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/UITextField/" style="font-size: 10px;">UITextField</a>
  </div>
</div>


  <iframe width="100%" height="140" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=1&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=1923610190&verifier=6af5ad6a&colors=fafafa,fafafa,666666,0082cb,ecfbfd&dpc=1"></iframe>

  <div class="widget tag">
<h3 class="title">友情链接</h3>
<ul class="entry">
<li><a href="http://opiece.me" title="Chillax's Blog" target="_blank">Chillax</a></li>
</ul>
</div>
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer"><div id="footer" >
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/huangjunhui/concise" target="_blank" title="Concise">Concise</a> © 2013 
		
		<a href="www.yoursite.com/about" target="_blank" title="李天昊">李天昊</a>
		
		</p>
</div>
</footer>
  <script src="//libs.baidu.com/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/counter.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

<div id="totop" style="position:fixed;bottom:100px;right:10px;cursor: pointer;">
<a title="返回顶部"><img src="/imgs/scrollup.png"/></a>
</div>
<script src="/js/totop.js"></script>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>


